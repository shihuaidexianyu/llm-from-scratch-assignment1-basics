"""Plot training/validation loss curves from the CSV log file."""

from __future__ import annotations

import argparse
import csv
from pathlib import Path
from typing import Iterable

import matplotlib

matplotlib.use("Agg")
import matplotlib.pyplot as plt

DEFAULT_LOG_FILE = Path("checkpoints/tinystories/loss_log.csv")
DEFAULT_OUT_FILE = Path("checkpoints/tinystories/loss_curve.png")


def _parse_float(value: str | None) -> float | None:
    if value is None:
        return None
    value = value.strip()
    if not value:
        return None
    try:
        return float(value)
    except ValueError:
        return None


def _parse_int(value: str | None) -> int | None:
    if value is None:
        return None
    value = value.strip()
    if not value:
        return None
    try:
        return int(float(value))
    except ValueError:
        return None


def read_loss_csv(path: Path) -> tuple[list[int], list[float], list[int], list[float]]:
    if not path.exists():
        raise FileNotFoundError(f"Log file not found: {path}")

    train_steps: list[int] = []
    train_losses: list[float] = []
    valid_steps: list[int] = []
    valid_losses: list[float] = []

    with path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        fieldnames = [name.strip() for name in reader.fieldnames or []]
        step_keys = [
            "step",
            "cstep",
            "global_step",
            "iter",
            "iteration",
        ]
        step_key = next((key for key in step_keys if key in fieldnames), None)
        if step_key is None:
            raise KeyError(f"Log file is missing a step column. Found columns: {', '.join(fieldnames)}")
        for row in reader:
            step = _parse_int(row.get(step_key))
            if step is None:
                continue
            train_loss = _parse_float(row.get("train_loss"))
            valid_loss = _parse_float(row.get("valid_loss"))
            if train_loss is not None:
                train_steps.append(step)
                train_losses.append(train_loss)
            if valid_loss is not None:
                valid_steps.append(step)
                valid_losses.append(valid_loss)

    if not train_losses and not valid_losses:
        raise ValueError("Log file has no train/valid loss entries.")

    return train_steps, train_losses, valid_steps, valid_losses


def _maybe_label(ax: plt.Axes, steps: Iterable[int], losses: Iterable[float], label: str) -> None:
    steps_list = list(steps)
    losses_list = list(losses)
    if not steps_list:
        return
    ax.plot(steps_list, losses_list, label=label)


def plot_loss_curve(
    train_steps: list[int],
    train_losses: list[float],
    valid_steps: list[int],
    valid_losses: list[float],
    out_file: Path,
    title: str,
) -> None:
    out_file.parent.mkdir(parents=True, exist_ok=True)
    fig, ax = plt.subplots(figsize=(7.5, 4.5))
    _maybe_label(ax, train_steps, train_losses, "train")
    _maybe_label(ax, valid_steps, valid_losses, "valid")

    ax.set_xlabel("step")
    ax.set_ylabel("loss")
    ax.set_title(title)
    ax.grid(alpha=0.3)
    if train_losses or valid_losses:
        ax.legend()

    fig.tight_layout()
    fig.savefig(out_file, dpi=150)
    plt.close(fig)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Plot loss curves from CSV logs.")
    parser.add_argument(
        "--log-file",
        type=Path,
        default=DEFAULT_LOG_FILE,
        help="CSV log file generated by training_together.py",
    )
    parser.add_argument(
        "--out-file",
        type=Path,
        default=DEFAULT_OUT_FILE,
        help="Output image path (png/pdf/svg).",
    )
    parser.add_argument(
        "--title",
        type=str,
        default="Loss vs Step",
        help="Plot title.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    train_steps, train_losses, valid_steps, valid_losses = read_loss_csv(args.log_file)
    plot_loss_curve(train_steps, train_losses, valid_steps, valid_losses, args.out_file, args.title)
    print(f"Saved loss curve to {args.out_file}")


if __name__ == "__main__":
    main()
